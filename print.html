<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sureberus</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/custom.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="sureberus.html">Sureberus</a></li><li><a href="directives.html"><strong aria-hidden="true">1.</strong> Directives</a></li><li><ol class="section"><li><a href="schema-registries.html"><strong aria-hidden="true">1.1.</strong> Schema registries</a></li><li><a href="schema-selection.html"><strong aria-hidden="true">1.2.</strong> Dynamically selecting schemas</a></li></ol></li><li><a href="python-schema.html"><strong aria-hidden="true">2.</strong> Python schema syntax</a></li><li><a href="cerberus.html"><strong aria-hidden="true">3.</strong> Differences from Cerberus</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Sureberus</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#sureberus" id="sureberus">Sureberus</a></h1>
<p>Sureberus is a data validation and transformation tool that is useful for validating and normalizing &quot;documents&quot; (nested data structures of basic Python data-types). You provide a schema which describes the expected structure of an object (and optionally, various directives that modify that structure), along with a document to validate and transform, and it returns the new version.</p>
<p>Sureberus is a spiritual descendent of <a href="https://github.com/pyeve/cerberus/">Cerberus</a>, more-or-less uses the same schema format.
There are some differences, though, which you can read about in <a href="./cerberus.html">Differences from Cerberus</a>.</p>
<h1><a class="header" href="#directives" id="directives">Directives</a></h1>
<p>This chapter provides a reference of all Sureberus schema directives.</p>
<h2><a class="header" href="#allow_unknown" id="allow_unknown">allow_unknown</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong>: <code>bool</code></p>
<p>When <strong>True</strong>, extra keys in a dictionary are passed through silently.</p>
<p>When <strong>False</strong>, keys that are found in a dictionary but which aren't specified in a fields schema will cause an error to be raised.</p>
<h2><a class="header" href="#allowed" id="allowed">allowed</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong>: <code>list</code> of arbitrary Python objects</p>
<p>The object being validated must be equal to one of the objects in the list in order to pass validation.</p>
<h2><a class="header" href="#of-anyof-oneof" id="of-anyof-oneof">*of (anyof, oneof)</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>list</code> of Sureberus schemas</p>
<p>Try applying schemas in sequence to the current value.</p>
<div class="sureberus-alert">
<p>These directives should be avoided, and <a href="#choose_schema"><code>choose_schema</code></a> should be strongly preferred, if possible.
These directives are generally inefficient and result in hard-to-read error messages.</p>
</div>
<p>When <code>anyof</code> is used, then as soon as any schema applies successfully, its result is returned.</p>
<p>When <code>oneof</code> is used, ALL schemas are checked, and if more than one can be applied successfully, an exception is raised
(this is very unlikely to be useful, you should probably just use <code>anyof</code>).</p>
<p>In either case, if none of the schemas can be applied without error, then a validation error will be raised.</p>
<div class="sureberus-info">
<p>Unlike Cerberus, these directives allow Transformation Directives to do their work as well.
If a schema can be applied successfully, the transformations it applies will be returned.</p>
</div>
<h2><a class="header" href="#choose_schema" id="choose_schema">choose_schema</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> described below</p>
<p>Choose a schema based on different factors of the input document and the current Context.
See <a href="./schema-selection.html">Dynamically selecting schemas</a> for more information.</p>
<p>The directive value is a dictionary which must contain one of the following keys.</p>
<ul>
<li>
<p><strong>when_key_is</strong></p>
<p><strong>type</strong> <code>dict</code> containing <code>key</code>, <code>choices</code>, and optionally <code>default_choice</code><br>
<strong>example</strong><br></p>
<pre><code class="language-yaml">choose_schema:
  when_key_is:
    key: &quot;type&quot;
    choices:
      &quot;type1&quot;: ...
      &quot;type2&quot;: ...
</code></pre>
<p>Dynamically selects a schema based on the value of a specific key, specified by the <code>key</code> sub-directive.
For example, if you have a value like <code>{&quot;type&quot;: &quot;foo&quot;, &quot;foo_specific&quot;: &quot;bar&quot;}</code>,
where the <code>foo</code> part determines which other keys might exist in the dict (like <code>foo_specific</code>),
then this directive can help you choose a specific schema to validate with.</p>
<p>When this directive is applied, it determines a schema to apply by accessing the key named by the <code>key</code> sub-directive in the value (which we'll call the &quot;choice&quot;).
If it's not found, then <code>default_choice</code> is used.
It then looks up the schema to use by looking for that &quot;choice&quot; in the <code>choices</code> sub-directive.</p>
</li>
<li>
<p><strong>when_key_exists</strong></p>
<p><strong>type</strong> <code>dict</code> (described below)<br>
<strong>example</strong></p>
<pre><code class="language-yaml">choose_schema:
  when_key_exists:
    &quot;keyA&quot;: ...
    &quot;keyB&quot;: ...
</code></pre>
<p>Dynamically selects a schema based on whether a certain dict key exists.</p>
<p>The directive should be provided a dictionary, where each <strong>key</strong> can potentially match a key in the value dictionary.
Each <strong>value</strong> in the directive dictionary should be a Sureberus schema to apply to the dictionary <strong>if</strong> the key exists in the dictionary.</p>
</li>
<li>
<p><strong>when_tag_is</strong></p>
<p><strong>type</strong> <code>dict</code> containing <code>tag</code>, <code>choices</code>, and optionally <code>default_choice</code><br>
<strong>example</strong></p>
<pre><code class="language-yaml">choose_schema:
  when_tag_is:
    tag: mytag
    choices:
      &quot;choiceA&quot;: ...
      &quot;choiceB&quot;: ...
</code></pre>
<p>This is very similar to <code>when_key_is</code>, but instead of choosing a schema based on the value of a dictionary key, it does it by using the context.
It goes hand-in-hand with the <a href="#set_tag"><code>set_tag</code></a> or <a href="#modify_context"><code>modify_context</code></a> directives.</p>
<p>When this directive is applied, it determines the schema to apply by looking up a tag named by the <code>tag</code> sub-directive (which we'll call the &quot;choice&quot;).
It then looks up the schema to use by looking for that &quot;choice&quot; in the <code>choices</code> sub-directive.</p>
</li>
<li>
<p><strong>function</strong></p>
<p><strong>type</strong> Python callable `(value, context) -&gt; Sureberus schema</p>
<p>Dynamically choose a schema to use based on the current value and the Context object.
The schema returned by the Python function will be applied to the value.</p>
</li>
</ul>
<h2><a class="header" href="#coerce" id="coerce">coerce</a></h2>
<p><strong>Transformation Directive</strong><br>
<strong>type</strong> Python callable <code>(value) -&gt; new value</code></p>
<p>Call a Python function with the value to get a new one to use.
It's important to note that this function is called <em>before</em> all other directives that might reject a value.
This is a good directive to use if you want to normalize invalid documents to a form that can be considered valid.</p>
<h2><a class="header" href="#coerce_post" id="coerce_post">coerce_post</a></h2>
<p><strong>Transformation Directive</strong><br>
<strong>type</strong> Python callable <code>(value) -&gt; new value</code></p>
<p>Call a Python function with the value to get a new one to use.
Unlike <code>coerce</code>, this function is applied <em>after</em> all other directives,
so it's allowed to return values that wouldn't validate according to other directives in your schema.</p>
<h2><a class="header" href="#modify_context" id="modify_context">modify_context</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Python callable <code>(value, Context) -&gt; Context</code></p>
<p>Run a Python function to allow it to modify the current Context.
The Python function will be passed the value and the current Context, and must return a new Context.
This is most often used to call <code>context.set_tag(key, value)</code> to add a new tag to the Context,
to later be used with <a href="#choose_schema"><code>choose_schema</code></a>.</p>
<p>See <a href="./schema-selection.html">Dynamically selecting schemas</a> for more information.</p>
<h2><a class="header" href="#keyschema" id="keyschema">keyschema</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Sureberus schema</p>
<p>Specify a schema to be applied to all keys in a dictionary.</p>
<h2><a class="header" href="#max" id="max">max</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number (or anything that supports the comparison operators)</p>
<p>Raises an exception if the value is greater than the given number.</p>
<h2><a class="header" href="#maxlength" id="maxlength">maxlength</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number</p>
<p>Raises an exception if the length of the value is greater than the given number.</p>
<h2><a class="header" href="#min" id="min">min</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number (or anything that supports the comparison operators)</p>
<p>Raises an exception if the value is less than the given number.</p>
<h2><a class="header" href="#nullable" id="nullable">nullable</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> <code>bool</code></p>
<p>Specifically allows None, even if it would conflict with other validation directives.
If the value is None, no other directives are applied.</p>
<div class="sureberus-info">
<p>This directive slightly differs Cerberus's implementation, which doesn't honor <code>nullable</code> when a <code>*of</code> directive is present.
See <a href="https://github.com/pyeve/cerberus/issues/373">cerberus#373</a>.</p>
</div>
<h2><a class="header" href="#regex" id="regex">regex</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> string (a regex)</p>
<p><em>If</em> the value is a string, and it does not match the given regex, an exception will be raised.</p>
<h2><a class="header" href="#registry" id="registry">registry</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> of schema names (strings) to Sureberus schemas</p>
<p>Registers named Sureberus schemas that can be referred to anywhere inside this schema.
This can be useful simply for factoring and schema reuse, but also enables recursive schemas.
To <em>use</em> a registered schema, simply put its name (as a string) any place where you would otherwise have a Sureberus schema.
<code>schema_ref</code> can also be useful for invoking registered schemas in certain situations.</p>
<p>See <a href="./schema-registries.html">Schema registries</a> for more information.</p>
<p>See also the <a href="#schema_ref">schema_ref</a> directive.</p>
<h2><a class="header" href="#schema_ref" id="schema_ref">schema_ref</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> string (naming a registered schema)</p>
<p>Applies the named schema (defined in a registry) to the current value.
This can be useful if you want to register a schema and use it at the same &quot;level&quot;.
Most of the time you don't need this, and instead just refer to the named schema by putting the schema name (as a string) anywhere you would normally specify a Sureberus schema.</p>
<p>See <a href="./schema-registries.html">Schema registries</a> for more information.</p>
<h2><a class="header" href="#schema" id="schema">schema</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Varies</p>
<p>The meaning of a <code>schema</code> key inside a schema changes based on the type of the <em>value</em>. This is strange, but it's how Cerberus did things.</p>
<p>When the value is a list, the directive is interpreted as a Sureberus schema to apply to each element of the list.</p>
<p>When the value is a dict, the keys of the dict are looked up in the directive, and used to find a Sureberus schema to apply to the associated value.</p>
<div class="sureberus-alert">
<p>The weird thing is that, e.g., it is possible to define a schema like <code>{'schema': {'type': 'integer'}}</code>.
Note that there is no <code>type</code> specified along with this schema, so you can try to apply it to lists or dicts.
Since we check the value at runtime, if it is a list, it validates each element of the list with that sub-schema.
If it is a dict, it <em>tries</em> to apply the schema directly as the field-schema, which leads to a runtime error when it tries to interpret the string <code>integer</code> as a Sureberus schema!</p>
<p>While originally Sureberus tried to match Cerberus bug-for-bug, this behavior is just too strange.
Sureberus will be introducing more specific directives to indicate element-schemas and field-schemas in the future.</p>
</div>
<h3><a class="header" href="#schema-for-lists" id="schema-for-lists">schema (for lists)</a></h3>
<p>The <code>schema</code> directive, when applied to a list, is very straightforward. It simply applies the schema to each element in the list.</p>
<h3><a class="header" href="#schema-for-dicts" id="schema-for-dicts">schema (for dicts)</a></h3>
<p>The <code>schema</code> directive on dicts is more complicated.</p>
<p>Each key matches a key that can potentially be found in the dictionary.</p>
<p>Each value is a Sureberus schema that can have a few <strong>extra</strong> directives, specific to dict fields.</p>
<ul>
<li><code>rename</code>: (string) If this is specified, then the dict key will be renamed to the specified key in the result.</li>
<li><code>required</code>: (<code>bool</code>) Indicates whether the field must be present.</li>
<li><code>excludes</code>: (<code>list of strings</code>) Specifies a list of keys which <em>must not exist</em> on the dictionary for this schema to validate.</li>
<li><code>default</code>: (object) A value to associate with the key in the resulting dict if the key was not present in the input.</li>
<li><code>default_setter</code>: (Python callable of <code>(dict) -&gt; value</code>) A Python function to call if the key was not present in the input.
It is passed the dictionary, and its return value will be used as the default.</li>
</ul>
<h2><a class="header" href="#set_tag" id="set_tag">set_tag</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> or string (described below)</p>
<p>Set a tag on the context. This directive can take various forms:</p>
<ul>
<li>
<p><code>&quot;set_tag&quot;: {&quot;tag_name&quot;: &quot;my-tag&quot;, &quot;key&quot;: &quot;foo&quot;}</code></p>
<p>This sets the tag named <code>my-tag</code> with the value of <code>value[&quot;foo&quot;]</code>.
So it assumes that the value that the schema is being applied to is a dict.</p>
</li>
<li>
<p><code>&quot;set_tag&quot;: &quot;foo&quot;</code></p>
<p>This sets the tag named <code>foo</code> with the value of <code>value[&quot;foo&quot;]</code>.
It's a shorthand for <code>{&quot;tag_name&quot;: &quot;foo&quot;, &quot;key&quot;: &quot;foo&quot;}</code>.</p>
</li>
<li>
<p><code>&quot;set_tag&quot;: {&quot;tag_name&quot;: &quot;my-tag&quot;, &quot;value&quot;: &quot;bar&quot;}</code></p>
<p>This sets the tag named <code>my-tag</code> with a value of <code>&quot;bar&quot;</code> -- that is, a hardcoded value specified in the schema.
This is very rarely useful, but is a convenient shorthand if you are referring to a schema that relies on a tag,
in a context where the tag doesn't vary based on anything.</p>
</li>
</ul>
<h2><a class="header" href="#type" id="type">type</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> string</p>
<p>Raises an exception if the type of the value does not match the directive.</p>
<p>These are the types available:</p>
<pre><code class="language-python">{
    &quot;none&quot;: type(None),
    &quot;integer&quot;: six.integer_types,
    &quot;float&quot;: (float,) + six.integer_types,
    &quot;number&quot;: (float,) + six.integer_types,
    &quot;dict&quot;: dict,
    &quot;list&quot;: list,
    &quot;string&quot;: six.string_types,
    &quot;boolean&quot;: bool,
}
</code></pre>
<h2><a class="header" href="#validator" id="validator">validator</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Python callable <code>(field, value, error_func) -&gt; None</code></p>
<p>Invokes a Python function to validate the value.
The function should return None if the value is valid, otherwise it should call
<code>error_func(field, &quot;error message&quot;)</code>.</p>
<h2><a class="header" href="#valueschema" id="valueschema">valueschema</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Sureberus schema</p>
<p>Applies the given Sureberus schema to all values in the dictionary (requires the value to be a dictionary).</p>
<h1><a class="header" href="#schema-registries" id="schema-registries">Schema registries</a></h1>
<p>Small, reusable &quot;chunks&quot; of schema can be defined in-line in the schema
specification, instead of requiring Python code to be written which sets up
registries. This allows for easy use of recursive schemas at any point in your
schema, or just a way to conveniently reuse some subschema in multiple places.
For example, here is a schema that validates any nested list of strings:</p>
<pre><code class="language-json">{
    &quot;registry&quot;: {
        &quot;nested_list&quot;: {
            &quot;type&quot;: &quot;list&quot;,
            &quot;schema&quot;: {
                &quot;anyof&quot;: [
                    {&quot;type&quot;: &quot;string&quot;},
                    &quot;nested_list&quot;,
                ],
            }
        }
    },
    &quot;type&quot;: &quot;dict&quot;,
    &quot;schema&quot;: {&quot;things&quot;: &quot;nested_list&quot;},
}
</code></pre>
<p>This will validate data like <code>{&quot;things&quot;: [&quot;one&quot;, [&quot;two&quot;, [&quot;three&quot;]]]}</code>.</p>
<p>Typically any place you can specify a schema, you can instead specify a string
which will be used to find a previously registered schema (references to
registered schemas are resolved lexically).</p>
<p>When you need to &quot;merge in&quot; a registered schema, you can use the <code>schema_ref</code>
directive. This can be useful if you want to register a schema and use it at
exactly the same level, for example:</p>
<pre><code class="language-json">{
    &quot;registry&quot;: {
        &quot;nested_list&quot;: {
            &quot;type&quot;: &quot;list&quot;,
            &quot;schema&quot;: {&quot;anyof&quot;: [{&quot;type&quot;: &quot;integer&quot;}, &quot;nested_list&quot;]}
        }
    },
    &quot;schema_ref&quot;: &quot;nested_list&quot;,
}
</code></pre>
<p>This will validate data like <code>[&quot;one&quot;, [&quot;two&quot;, [&quot;three&quot;]]]</code>.</p>
<h1><a class="header" href="#dynamically-selecting-schemas" id="dynamically-selecting-schemas">Dynamically selecting schemas</a></h1>
<p>Sureberus has a directive for <em>selecting</em> schemas to apply based on various aspects of the input value, called <a href="./directives.html#choose_schema"><code>choose_schema</code></a>. This directive is meant to be passed a dict, which must include a single sub-directive.</p>
<h2><a class="header" href="#schema-selection-based-on-dict-keys-when_key_is-when_key_exists" id="schema-selection-based-on-dict-keys-when_key_is-when_key_exists">Schema selection based on dict keys: when_key_is, when_key_exists</a></h2>
<p>There are two options for selecting a schema based on dict keys.</p>
<ul>
<li><code>when_key_is</code> is for when you have a dictionary that contains something like a <code>&quot;type&quot;</code> key, whose value lets you identify a specific schema to apply.</li>
<li><code>when_key_exists</code> is for when you have a dictionary where different keys appear, and the existence of specific keys allows you to choose a schema to apply.</li>
</ul>
<h3><a class="header" href="#when_key_is" id="when_key_is">when_key_is</a></h3>
<p>Use this when you have dictionaries that have a fixed key, such as <code>&quot;type&quot;</code>,
which specifies some specific format to use. For example, if you have data that
can look like this:</p>
<pre><code class="language-json">{&quot;type&quot;: &quot;elephant&quot;, &quot;trunk_length&quot;: 60}
{&quot;type&quot;: &quot;eagle&quot;, &quot;wingspan&quot;: 50}
</code></pre>
<p>Then you would use <code>when_key_is</code> in your schema like this (in YAML syntax):</p>
<pre><code class="language-yaml">type: dict
choose_schema:
  when_key_is:
    key: &quot;type&quot;
    choices:
      &quot;elephant&quot;:
        schema:
          &quot;trunk_length&quot;: {&quot;type&quot;: &quot;integer&quot;}
      &quot;eagle&quot;:
        schema:
          &quot;wingspan&quot;: {&quot;type&quot;: &quot;integer&quot;}
</code></pre>
<p>When the value contains a <code>type</code> key of <code>elephant</code>, Sureberus will choose the schema that contains <code>trunk_length</code>.
When the type is <code>eagle</code>, it will choose the schema containing <code>wingspan</code>.</p>
<h3><a class="header" href="#when_key_exists" id="when_key_exists">when_key_exists</a></h3>
<p>Use this when you have dictionaries where you must choose the schema based on keys that exist in the data exclusively for their type of data.
For example, if you have data that can look like this:</p>
<pre><code class="language-json">{&quot;image_url&quot;: &quot;foo.jpg&quot;, &quot;width&quot;: 30}
{&quot;color&quot;: &quot;red&quot;}
</code></pre>
<p>Then you would use <code>when_key_exists</code>, like this (in YAML):</p>
<pre><code class="language-yaml">type: dict
choose_schema:
  when_key_exists:
    &quot;image_url&quot;:
      schema:
        &quot;image_url&quot;: {&quot;type&quot;: &quot;string&quot;}
        &quot;width&quot;: {&quot;type&quot;: &quot;integer&quot;}
    &quot;color&quot;:
      schema:
        &quot;color&quot;: {&quot;type&quot;: &quot;string&quot;}
</code></pre>
<p>Sureberus looks at the keys in the dictionary, and if one of the keys that are listed in <code>choices</code> are there, it will choose the corresponding schema.</p>
<h2><a class="header" href="#schema-selection-based-on-context" id="schema-selection-based-on-context">Schema selection based on context</a></h2>
<p>While <code>when_key_is</code> can work when you need to vary the way an object is validated or transformed
based on a key <em>existing in that same object</em>, sometimes the relationship of the schema specifier
and the content to be varied is not so tightly bound.</p>
<p>For example, let's take a look at the following data:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;foo&quot;,
    &quot;common&quot;: {},
    &quot;data_service&quot;: {
        &quot;renderers&quot;: [
            {&quot;foo_specific&quot;: &quot;bar&quot;}
        ]
    }
}
</code></pre>
<p>Let's assume that this structure is mostly fixed. We have a <code>type</code> key in
the top-level dict, but the only part of the schema that we want to vary is inside the
<code>renderers</code> list. If all we have is <code>when_key_is</code>, then we need to end up duplicating the whole
<code>data_services</code> and <code>renderers</code> schemas inside the <code>choices</code> directive of the <code>when_key_is</code> construct.</p>
<p>Sureberus provides a mechanism that allows you to define schemas that vary based on context, even
if that context comes from much higher up in the object. We basically have a way to &quot;remember&quot; the
value of <code>type</code>, so that it can be used later when applying schemas to values nested arbitrarily
deeply in the object.</p>
<p>There are four directives that provide these mechanisms. For most cases, you only need to care
about the first two of them:</p>
<ul>
<li><a href="./directives.html#set_tag"><code>set_tag</code></a> - save a tag (a key/value pair) in the Context,</li>
<li><a href="./directives.html#choose_schema"><code>choose_schema</code></a> with <code>when_tag_is</code> - select a schema based on a saved tag found in the Context,</li>
<li><a href="./directives.html#modify_context"><code>modify_context</code></a> - run an arbitrary Python function that can manipulate the Context (including the tags),</li>
<li><a href="./directives.html#choose_schema"><code>choose_schema</code></a> with <code>function</code> - run an arbitrary Python function that can select a schema based on the Context.</li>
</ul>
<p>The latter two, <code>modify_context</code> and <code>choose_schema</code> are generalizations of the first, and they
don't often need to be used.</p>
<p>Here's an example of a schema that can parse our sample data, using the Python schema syntax.</p>
<pre><code class="language-python">schema = S.Dict(
  set_tag=&quot;type&quot;,
  schema={
    &quot;type&quot;: S.String(),
    &quot;common&quot;: S.Dict(),
    &quot;data_service&quot;: S.Dict(
      schema={
        &quot;renderers&quot;: S.List(
          schema=S.Dict(
            choose_schema=S.when_tag_is(
              &quot;type&quot;,
              {
                &quot;foo&quot;: S.Dict(schema={&quot;foo_specific&quot;: S.String()}),
                &quot;bar&quot;: S.Dict(schema={&quot;bar_specific&quot;: S.Integer()}),
              })))})})
</code></pre>
<p>Here we're using the <code>set_tag</code> directive with its shorthand for specifying a tag name that will be equivalent to the name of the key to look up in the dict.
When Sureberus applies this schema to the top-level <code>dict</code>, it looks for the key named <code>type</code>, and stores its value in the Context under a tag named <code>type</code>.
Then, deeper inside this schema, we make use of the <code>choose_schema</code> directive with the <code>when_tag_is</code> sub-directive.
We pass the tag name <code>type</code> here, so it looks up the value associated with the <code>type</code> tag in the Context, and uses that to select the corresponding schema defined in the choices passed to <code>when_tag_is</code>.
Thus, when the top-level dict has <code>&quot;type&quot;: &quot;foo&quot;</code>, Sureberus will ultimately select the schema containing <code>&quot;foo_specific&quot;</code>.</p>
<h1><a class="header" href="#python-schema-syntax" id="python-schema-syntax">Python schema syntax</a></h1>
<p>If you want to construct a schema from Python code instead of storing it as
JSON or YAML, sureberus provides a more terse syntax for it.</p>
<p>Here's a standard dict-based schema, using an 80-character limit and strict
newline/indent-based line wrapping:</p>
<pre><code class="language-python">myschema = {
    'type': 'dict',
    'anyof': [
        {'schema': {'gradient': {'type': 'string'}}},
        {
            'schema': {
                'image': {'type': 'string'},
                'opacity': {'type': 'integer', 'default': 100},
            }
        },
    ],
}
</code></pre>
<p>And here is a <code>sureberus.schema</code>-based schema, using the same line-wrapping
rules:</p>
<pre><code class="language-python">from sureberus.schema import Dict, SubSchema, String, Integer
myschema = Dict(
    anyof=[
        SubSchema(gradient=String()),
        SubSchema(image=String(), opacity=Integer(default=100))
    ]
)
</code></pre>
<h1><a class="header" href="#differences-from-cerberus" id="differences-from-cerberus">Differences from Cerberus</a></h1>
<h2><a class="header" href="#transformation-and-validation" id="transformation-and-validation">Transformation AND validation</a></h2>
<p>Sureberus exists because Cerberus wasn't flexible enough for our use.
Most importantly, Cerberus strictly separates transformation (what the Cerberus documentation calls &quot;Normalization&quot;) from validation;
if you want to transform a document with Cerberus, you can't also make sure it's valid at the same time.
This can lead to some surprising limitations.</p>
<p>For example,</p>
<pre><code class="language-python">from sureberus import normalize_dict
from cerberus import Validator

schema = {
    &quot;x&quot;: {
        &quot;anyof&quot;: [
            {&quot;type&quot;: &quot;dict&quot;, &quot;schema&quot;: {&quot;y&quot;: {&quot;type&quot;: &quot;integer&quot;, &quot;default&quot;: 0}}},
            {&quot;type&quot;: &quot;integer&quot;},
        ]
    }
}
</code></pre>
<p>Here we have a schema that says:</p>
<ul>
<li>this is a dict
<ul>
<li>whose <code>x</code> field can either be
<ul>
<li>an integer,</li>
<li>or a dict,
<ul>
<li>containing a <code>y</code> field which defaults to 0.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Let's try using it with Sureberus.</p>
<pre><code class="language-python">assert normalize_dict(schema, {&quot;x&quot;: {}}) == {&quot;x&quot;: {&quot;y&quot;: 0}}
assert normalize_dict(schema, {&quot;x&quot;: 5}) == {&quot;x&quot;: 5}
</code></pre>
<p>These assertions run fine. Sureberus tries to normalize the value with each schema in turn, and returns the result of the first one that succeeds.</p>
<p>Now let's try with Cerberus.</p>
<pre><code class="language-python">v = Validator(schema)
assert v.normalized({&quot;x&quot;: {}}) == {&quot;x&quot;: {&quot;y&quot;: 0}} # This fails!
assert v.normalized({&quot;x&quot;: 5}) == {&quot;x&quot;: 5}
</code></pre>
<p>The first assertion fails, since Cerberus is returning <code>{'x': {}}</code> -- it seems to be completely disregarding our <code>default</code> directive. Why is this?</p>
<p>It's actually deeper than that, still.
Let's see what happens when we pass something that obviously shouldn't even validate:</p>
<pre><code class="language-python">
# Sureberus:
from sureberus.errors import NoneMatched
with pytest.raises(NoneMatched):
    normalize_dict(schema, {&quot;x&quot;: &quot;foo&quot;})

# Cerberus:
with pytest.raises(Exception): # This fails!
    v.normalized({&quot;x&quot;: &quot;foo&quot;})
</code></pre>
<p>Cerberus returns the original document without throwing any sort of exception, even though our schema indicates that the <code>x</code> key must have a value that's either an integer or a dict.
This is expected as per Cerberus's documentation: you have to validate separately from normalization, by using either the <code>validate</code> method or the <code>normalized</code> method.
But because it separates these concepts so strictly, and because some directives like <code>anyof</code> are considered <em>only</em> validation rules and not normalization rules,
it's impossible to express the transformation we want.</p>
<h2><a class="header" href="#schema-selection" id="schema-selection">Schema Selection</a></h2>
<p>To improve upon the poor error messages that can occur when using &quot;variable schemas&quot; (the <a href="./directives.html#of-anyof-oneof"><code>oneof</code> and <code>anyof</code></a> directives) in Cerberus,
we've implemented facilities in Sureberus that make it much more clear how to choose schemas, with the <a href="./directives.html#choose_schema"><code>choose_schema</code></a> directive.</p>
<p>Not only does this make the schema easier to reason about, it makes error messages much nicer: with <code>anyof</code>, we have to say:</p>
<blockquote>
<p>&quot;Sorry, your value didn't match this schema, or that schema, or that schema...&quot;</p>
</blockquote>
<p>But with the mechanisms available through <code>choose_schema</code>, we get to say:</p>
<blockquote>
<p>&quot;I know you want to use THIS schema, because you had a field in your dictionary that indicated which schema to use. This is how it doesn't match...&quot;</p>
</blockquote>
<p>The <code>choose_schema</code> facility is documented more thoroughly in <a href="./schema-selection.html">Schema selection</a>.</p>
<h2><a class="header" href="#in-line-schema-registries" id="in-line-schema-registries">In-line schema registries</a></h2>
<p>In Cerberus, you have to invoke Python code to register schemas.
This means you can't describe a recursive schema without writing custom Python code (as far as I have been able to figure out, anyway).
With Sureberus, you can take advantage of the <a href="./directives.html#registry"><code>registry</code></a> directive which allows you to declare named schemas.
This means that recursive schemas are easy to define in Sureberus.
See <a href="./schema-registries.html">Schema registries</a> for more information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
