<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sureberus</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/custom.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="sureberus.html">Sureberus</a></li><li><a href="directives.html"><strong aria-hidden="true">1.</strong> Directives</a></li><li><ol class="section"><li><a href="schema-registries.html"><strong aria-hidden="true">1.1.</strong> Schema registries</a></li><li><a href="schema-selection.html"><strong aria-hidden="true">1.2.</strong> Dynamically selecting schemas</a></li></ol></li><li><a href="python-schema.html"><strong aria-hidden="true">2.</strong> Python schema syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Sureberus</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#sureberus" id="sureberus">Sureberus</a></h1>
<p>Sureberus is a data validation and transformation tool that is useful for validating and normalizing &quot;documents&quot; (nested data structures of basic Python data-types). You provide a schema which describes the expected structure of an object (and optionally, various directives that modify that structure), along with a document to validate and transform, and it returns the new version.</p>
<p>Sureberus's schema format is based on <a href="https://github.com/pyeve/cerberus/">Cerberus</a>. It doesn't implement all of the features of that library, and where it does implement a feature it doesn't always implement it in the exact same way.</p>
<p>Sureberus exists because Cerberus wasn't flexible enough for my use. Most importantly, Cerberus strictly separates transformation (what the Cerberus documentation calls &quot;Normalization&quot;) from validation; if you want to transform a document, you can't also make sure it's valid at the same time. This can lead to some surprising limitations, some of which are documented below.</p>
<h1><a class="header" href="#directives" id="directives">Directives</a></h1>
<p>This chapter provides a reference of all Sureberus schema directives.</p>
<h2><a class="header" href="#allow_unknown" id="allow_unknown">allow_unknown</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong>: <code>bool</code></p>
<p>When <strong>True</strong>, extra keys in a dictionary are passed through silently.</p>
<p>When <strong>False</strong>, keys that are found in a dictionary but which aren't specified in a fields schema will cause an error to be raised.</p>
<h2><a class="header" href="#allowed" id="allowed">allowed</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong>: <code>list</code> of arbitrary Python objects</p>
<p>The object being validated must be equal to one of the objects in the list in order to pass validation.</p>
<h2><a class="header" href="#of-anyof-oneof" id="of-anyof-oneof">*of (anyof, oneof)</a></h2>
<p><strong>Validation &amp; Transformation Directive</strong><br>
<strong>type</strong> <code>list</code> of Sureberus schemas</p>
<p>Try applying schemas in sequence to the current value.</p>
<div class="sureberus-alert">
<p>These directives should be avoided, and <a href="./schema-selection.html">dynamic schema selection</a> should be strongly preferred.
These directives are generally inefficient and result in hard-to-read error messages.</p>
</div>
<p>When <code>anyof</code> is used, then as soon as any schema applies successfully, its result is returned.</p>
<p>When <code>oneof</code> is used, ALL schemas are checked, and if more than one can be applied successfully, an exception is raised
(this is very unlikely to be useful, you should probably just use <code>anyof</code>).</p>
<p>In either case, if none of the schemas can be applied without error, then a validation error will be raised.</p>
<div class="sureberus-info">
<p>Unlike Cerberus, these directives allow Transformation Directives to do their work as well.
If a schema can be applied successfully, the transformations it applies will be returned.</p>
</div>
<h2><a class="header" href="#choose_schema" id="choose_schema">choose_schema</a></h2>
<p><strong>Validation &amp; Transformation Directive</strong><br>
<strong>type</strong> Python callable <code>(value, context)</code> -&gt; Sureberus schema</p>
<p>Dynamically choose a schema to use based on the current value and the Context object.
The schema returned by the Python function will be applied to the value.</p>
<p>See <a href="./schema-selection.html">Dynamically selecting schemas</a> for more information.</p>
<h2><a class="header" href="#coerce" id="coerce">coerce</a></h2>
<p><strong>Transformation Directive</strong><br>
<strong>type</strong> Python callable <code>(value) -&gt; new value</code></p>
<p>Call a Python function with the value to get a new one to use.
It's important to note that this function is called <em>before</em> all other directives that might reject a value.
This is a good directive to use if you want to normalize invalid documents to a form that can be considered valid.</p>
<h2><a class="header" href="#coerce_post" id="coerce_post">coerce_post</a></h2>
<p><strong>Transformation Directive</strong><br>
<strong>type</strong> Python callable <code>(value) -&gt; new value</code></p>
<p>Call a Python function with the value to get a new one to use.
Unlike <code>coerce</code>, this function is applied <em>after</em> all other directives,
so it's allowed to return values that wouldn't validate according to other directives in your schema.</p>
<h2><a class="header" href="#hook_context" id="hook_context">hook_context</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Python callable <code>(value, Context) -&gt; Context</code></p>
<p>Run a Python function when this schema is applied.
The Python function will be passed the value and the current Context, and must return a new Context.
This is most often used to call <code>context.set_tag(key, value)</code> to add a new tag to the Context,
to later be used with directives such as <code>choose_schema</code> and <code>when_tag_is</code>.</p>
<p>See <a href="./schema-selection.html">Dynamically selecting schemas</a> for more information.</p>
<h2><a class="header" href="#keyschema" id="keyschema">keyschema</a></h2>
<p><strong>Validation &amp; Transformation Directive</strong><br>
<strong>type</strong> Sureberus schema</p>
<p>Specify a schema to be applied to all keys in a dictionary.</p>
<h2><a class="header" href="#max" id="max">max</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number (or anything that supports the comparison operators)</p>
<p>Raises an exception if the value is greater than the given number.</p>
<h2><a class="header" href="#maxlength" id="maxlength">maxlength</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number</p>
<p>Raises an exception if the length of the value is greater than the given number.</p>
<h2><a class="header" href="#min" id="min">min</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Number (or anything that supports the comparison operators)</p>
<p>Raises an exception if the value is less than the given number.</p>
<h2><a class="header" href="#nullable" id="nullable">nullable</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> <code>bool</code></p>
<p>Specifically allows None, even if it would conflict with other validation directives.
If the value is None, no other directives are applied.</p>
<p><strong>Note</strong> that this is behavior differs from Cerberus. See <a href="https://github.com/pyeve/cerberus/issues/373">cerberus#373</a>.</p>
<h2><a class="header" href="#regex" id="regex">regex</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> string (a regex)</p>
<p><em>If</em> the value is a string, and it does not match the given regex, an exception will be raised.</p>
<h2><a class="header" href="#registry" id="registry">registry</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> of schema names (strings) to Sureberus schemas</p>
<p>Registers named Sureberus schemas that can be referred to anywhere inside this schema.
This can be useful simply for factoring and schema reuse, but also enables recursive schemas.
To <em>use</em> a registered schema, simply put its name (as a string) any place where you would otherwise have a Sureberus schema.
<code>schema_ref</code> can also be useful for invoking registered schemas in certain situations.</p>
<p>See <a href="./schema-registries.html">Schema registries</a> for more information.</p>
<h2><a class="header" href="#schema_ref" id="schema_ref">schema_ref</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> string (naming a registered schema)</p>
<p>Applies the named schema (defined in a registry) to the current value.
This can be useful if you want to register a schema and use it at the same &quot;level&quot;.
Most of the time you don't need this, and instead just refer to the named schema by putting the schema name (as a string) anywhere you would normally specify a Sureberus schema.</p>
<p>See <a href="./schema-registries.html">Schema registries</a> for more information.</p>
<h2><a class="header" href="#schema" id="schema">schema</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> Varies</p>
<p>The meaning of a <code>schema</code> key inside a schema changes based on the type of the <em>value</em>. This is strange, but it's how Cerberus did things.</p>
<p>When the value is a list, the directive is interpreted as a Sureberus schema to apply to each element of the list.</p>
<p>When the value is a dict, the keys of the dict are looked up in the directive, and used to find a Sureberus schema to apply to the associated value.</p>
<div class="sureberus-alert">
<p>The weird thing is that, e.g., it is possible to define a schema like <code>{'schema': {'type': 'integer'}}</code>.
Note that there is no <code>type</code> specified along with this schema, so you can try to apply it to lists or dicts.
Since we check the value at runtime, if it is a list, it validates each element of the list with that sub-schema.
If it is a dict, it <em>tries</em> to apply the schema directly as the field-schema, which leads to a runtime error when it tries to interpret the string <code>integer</code> as a Sureberus schema!</p>
<p>While originally Sureberus tried to match Cerberus bug-for-bug, this behavior is just too strange.
Sureberus will be introducing more specific directives to indicate element-schemas and field-schemas in the future.</p>
</div>
<h3><a class="header" href="#schema-for-lists" id="schema-for-lists">schema (for lists)</a></h3>
<p>The <code>schema</code> directive, when applied to a list, is very straightforward. It simply applies the schema to each element in the list.</p>
<h3><a class="header" href="#schema-for-dicts" id="schema-for-dicts">schema (for dicts)</a></h3>
<p>The <code>schema</code> directive on dicts is more complicated.</p>
<p>Each key matches a key that can potentially be found in the dictionary.</p>
<p>Each value is a Sureberus schema that can have a few <strong>extra</strong> directives, specific to dict fields.</p>
<ul>
<li><code>rename</code>: (string) If this is specified, then the dict key will be renamed to the specified key in the result.</li>
<li><code>required</code>: (<code>bool</code>) Indicates whether the field must be present.</li>
<li><code>excludes</code>: (<code>list of strings</code>) Specifies a list of keys which <em>must not exist</em> on the dictionary for this schema to validate.</li>
<li><code>default</code>: (object) A value to associate with the key in the resulting dict if the key was not present in the input.</li>
<li><code>default_setter</code>: (Python callable of <code>(dict) -&gt; value</code>) A Python function to call if the key was not present in the input.
It is passed the dictionary, and its return value will be used as the default.</li>
</ul>
<h2><a class="header" href="#set_tag" id="set_tag">set_tag</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> or string (described below)</p>
<p>Set a tag on the context. This directive can take various forms:</p>
<ul>
<li>
<p><code>&quot;set_tag&quot;: {&quot;tag_name&quot;: &quot;my-tag&quot;, &quot;key&quot;: &quot;foo&quot;}</code></p>
<p>This sets the tag named <code>my-tag</code> with the value of <code>value[&quot;foo&quot;]</code>.
So it assumes that the value that the schema is being applied to is a dict.</p>
</li>
<li>
<p><code>&quot;set_tag&quot;: &quot;foo&quot;</code></p>
<p>This sets the tag named <code>foo</code> with the value of <code>value[&quot;foo&quot;]</code>.
It's a shorthand for <code>{&quot;tag_name&quot;: &quot;foo&quot;, &quot;key&quot;: &quot;foo&quot;}</code>.</p>
</li>
<li>
<p><code>&quot;set_tag&quot;: {&quot;tag_name&quot;: &quot;my-tag&quot;, &quot;value&quot;: &quot;bar&quot;}</code></p>
<p>This sets the tag named <code>my-tag</code> with a value of <code>&quot;bar&quot;</code> -- that is, a hardcoded value specified in the schema.
This is very rarely useful, but is a convenient shorthand if you are referring to a schema that relies on a tag,
in a context where the tag doesn't vary based on anything.</p>
</li>
</ul>
<h2><a class="header" href="#type" id="type">type</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> string</p>
<p>Raises an exception if the type of the value does not match the directive.</p>
<p>These are the types available:</p>
<pre><code class="language-python">{
    &quot;none&quot;: type(None),
    &quot;integer&quot;: six.integer_types,
    &quot;float&quot;: (float,) + six.integer_types,
    &quot;number&quot;: (float,) + six.integer_types,
    &quot;dict&quot;: dict,
    &quot;list&quot;: list,
    &quot;string&quot;: six.string_types,
    &quot;boolean&quot;: bool,
}
</code></pre>
<h2><a class="header" href="#validator" id="validator">validator</a></h2>
<p><strong>Validation Directive</strong><br>
<strong>type</strong> Python callable <code>(field, value, error_func) -&gt; None</code></p>
<p>Invokes a Python function to validate the value.
The function should return None if the value is valid, otherwise it should call
<code>error_func(field, &quot;error message&quot;)</code>.</p>
<h2><a class="header" href="#valueschema" id="valueschema">valueschema</a></h2>
<p><strong>Validation &amp; Transformation Directive</strong><br>
<strong>type</strong> Sureberus schema</p>
<p>Applies the given Sureberus schema to all values in the dictionary (requires the value to be a dictionary).</p>
<h2><a class="header" href="#when_key_exists" id="when_key_exists">when_key_exists</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> (described below)</p>
<p>Dynamically selects a schema based on whether certain dict key exists.</p>
<p>The directive should be provided a dictionary, where each <strong>key</strong> can potentially match a key in the value dictionary.
Each <strong>value</strong> in the directive dictionary should be a Sureberus schema to apply to the dictionary <strong>if</strong> the key exists in the dictionary.</p>
<p>See <a href="./schema-selection.html">Schema selection</a> for more information.</p>
<h2><a class="header" href="#when_key_is" id="when_key_is">when_key_is</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> containing <code>key</code>, <code>choices</code>, and potentially <code>default_choice</code></p>
<p>Dynamically selects a schema based on the value of a specific key, specified by the <code>key</code> sub-directive.
For example, if you have a value like <code>{&quot;type&quot;: &quot;foo&quot;, &quot;foo_specific&quot;: &quot;bar&quot;}</code>,
where the <code>foo</code> part determines which other keys might exist in the dict (like <code>foo_specific</code>),
then this directive can help you choose a specific schema to validate with.</p>
<p>When this directive is applied, it determines a schema to apply by accessing the key named by the <code>key</code> sub-directive in the value (which we'll call the &quot;choice&quot;).
If it's not found, then <code>default_choice</code> is used.
It then looks up the schema to use by looking for that &quot;choice&quot; in the <code>choices</code> sub-directive.</p>
<p>See <a href="./schema-selection.html">Schema selection</a> for more information.</p>
<h2><a class="header" href="#when_tag_is" id="when_tag_is">when_tag_is</a></h2>
<p><strong>Meta Directive</strong><br>
<strong>type</strong> <code>dict</code> containing <code>tag</code> and <code>choices</code>.</p>
<p>This is very similar to <code>when_key_is</code>, but instead of choosing a schema based on the value of a dictionary key, it does it by using the context.
It goes hand-in-hand with the <code>set_tag</code> or <code>hook_context</code> directives.</p>
<p>When this directive is applied, it determines the schema to apply by looking up a tag named by the <code>tag</code> sub-directive (which we'll call the &quot;choice&quot;).
It then looks up the schema to use by looking for that &quot;choice&quot; in the <code>choices</code> sub-directive.</p>
<p>See <a href="./schema-selection.html">Schema selection</a> for more information.</p>
<h1><a class="header" href="#schema-registries" id="schema-registries">Schema registries</a></h1>
<p>Small, reusable &quot;chunks&quot; of schema can be defined in-line in the schema
specification, instead of requiring Python code to be written which sets up
registries. This allows for easy use of recursive schemas at any point in your
schema, or just a way to conveniently reuse some subschema in multiple places.
For example, here is a schema that validates any nested list of strings:</p>
<pre><code class="language-json">{
    &quot;registry&quot;: {
        &quot;nested_list&quot;: {
            &quot;type&quot;: &quot;list&quot;,
            &quot;schema&quot;: {
                &quot;anyof&quot;: [
                    {&quot;type&quot;: &quot;string&quot;},
                    &quot;nested_list&quot;,
                ],
            }
        }
    },
    &quot;type&quot;: &quot;dict&quot;,
    &quot;schema&quot;: {&quot;things&quot;: &quot;nested_list&quot;},
}
</code></pre>
<p>This will validate data like <code>{&quot;things&quot;: [&quot;one&quot;, [&quot;two&quot;, [&quot;three&quot;]]]}</code>.</p>
<p>Typically any place you can specify a schema, you can instead specify a string
which will be used to find a previously registered schema (references to
registered schemas are resolved lexically).</p>
<p>When you need to &quot;merge in&quot; a registered schema, you can use the <code>schema_ref</code>
directive. This can be useful if you want to register a schema and use it at
exactly the same level, for example:</p>
<pre><code class="language-json">{
    &quot;registry&quot;: {
        &quot;nested_list&quot;: {
            &quot;type&quot;: &quot;list&quot;,
            &quot;schema&quot;: {&quot;anyof&quot;: [{&quot;type&quot;: &quot;integer&quot;}, &quot;nested_list&quot;]}
        }
    },
    &quot;schema_ref&quot;: &quot;nested_list&quot;,
}
</code></pre>
<p>This will validate data like <code>[&quot;one&quot;, [&quot;two&quot;, [&quot;three&quot;]]]</code>.</p>
<h1><a class="header" href="#dynamically-selecting-schemas" id="dynamically-selecting-schemas">Dynamically selecting schemas</a></h1>
<h2><a class="header" href="#schema-selection-based-on-dict-keys-when_key_is-when_key_exists" id="schema-selection-based-on-dict-keys-when_key_is-when_key_exists">Schema selection based on dict keys: when_key_is, when_key_exists</a></h2>
<p>Often times when <a href="http://docs.python-cerberus.org/en/stable/validation-rules.html#of-rules"><code>anyof</code> or <code>oneof</code></a> are used, what we really want to do is <em>select</em> a schema based on dict keys.</p>
<p>There are two options for this, which should be used in preference to <code>anyof</code> or <code>oneof</code>, when possible, as they provide much better error messages.</p>
<h3><a class="header" href="#when_key_is-1" id="when_key_is-1">when_key_is</a></h3>
<p>Use this when you have dictionaries that have a fixed key, such as <code>&quot;type&quot;</code>,
which specifies some specific format to use. For example, if you have data that
can look like this:</p>
<pre><code class="language-json">{&quot;type&quot;: &quot;elephant&quot;, &quot;trunk_length&quot;: 60}
{&quot;type&quot;: &quot;eagle&quot;, &quot;wingspan&quot;: 50}
</code></pre>
<p>Then you would use <code>when_key_is</code>, like this:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;dict&quot;,
    &quot;when_key_is&quot;: {
        &quot;key&quot;: &quot;type&quot;,
        &quot;choices&quot;: {
            &quot;elephant&quot;: {
                &quot;schema&quot;: {&quot;trunk_length&quot;: {&quot;type&quot;: &quot;integer&quot;}}
            },
            &quot;eagle&quot;: {
                &quot;schema&quot;: {&quot;wingspan&quot;: {&quot;type&quot;: &quot;integer&quot;}}
            },
        }
    }
}
</code></pre>
<p>You can also specify a <code>default_choice</code> inside of the <code>when_key_is</code> directive,
to specify which choice to use if the (e.g.) <code>type</code> key is elided from the
value being validated.</p>
<h3><a class="header" href="#when_key_exists-1" id="when_key_exists-1">when_key_exists</a></h3>
<p>Use this when you have dictionaries where you must choose the schema based on
keys that exist in the data exclusively for their type of data. For example, if
you have data that can look like this:</p>
<pre><code class="language-json">{&quot;image_url&quot;: &quot;foo.jpg&quot;, &quot;width&quot;: 30}
{&quot;color&quot;: &quot;red&quot;}
</code></pre>
<p>Then you would use <code>when_key_exists</code>, like this:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;dict&quot;,
    &quot;when_key_exists&quot;: {
        &quot;image_url&quot;: {
            &quot;schema&quot;: {&quot;image_url&quot;: {&quot;type&quot;: &quot;string&quot;}, &quot;width&quot;: {&quot;type&quot;: &quot;integer&quot;}}
        },
        &quot;color&quot;: {
            &quot;schema&quot;: {&quot;color&quot;: {&quot;type&quot;: &quot;string&quot;}}
        },
    }
}
</code></pre>
<h2><a class="header" href="#schema-selection-based-on-context" id="schema-selection-based-on-context">Schema selection based on context</a></h2>
<p>While <code>when_key_is</code> can work when you need to vary the way an object is validated or transformed
based on a key <em>existing in that same object</em>, sometimes the relationship of the schema specifier
and the content to be varied is not so tightly bound.</p>
<p>For example, let's take a look at the following data:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;foo&quot;,
    &quot;common&quot;: {},
    &quot;data_service&quot;: {
        &quot;renderers&quot;: [
            {&quot;foo_specific&quot;: &quot;bar&quot;}
        ]
    }
}
</code></pre>
<p>Let's assume that largely, this structure is defined by a fixed schema. We have a <code>type</code> key in
the top-level dict, but the only part of the schema that we want to vary is inside the
<code>renderers</code> list. If all we have is <code>when_key_is</code>, then we need to end up duplicating the whole
<code>data_services</code> and <code>renderers</code> inside the <code>choices</code> directive of the <code>when_key_is</code> construct.</p>
<p>Sureberus provides a mechanism that allows you to define schemas that vary based on context, even
if that context comes from much higher up in the object. We basically have a way to &quot;remember&quot; the
value of <code>type</code>, so that it can be used later when applying schemas to values nested arbitrarily
deeply in the object.</p>
<p>There are four directives that provide these mechanisms. For most cases, you only need to care
about the first two of them:</p>
<ul>
<li><code>set_tag</code> - save a tag (a key/value pair) in the Context,</li>
<li><code>when_tag_is</code> - select a schema based on a saved tag found in the Context,</li>
<li><code>hook_context</code> - run an arbitrary Python function that can manipulate the Context (including
the tags),</li>
<li><code>choose_schema</code> - run an arbitrary Python function that can select a schema based on the
Context.</li>
</ul>
<p>The latter two, <code>hook_context</code> and <code>choose_schema</code> are generalizations of the first, and they
don't often need to be used.</p>
<p>Here's an example of a schema that can parse our sample data, encoded as YAML:</p>
<pre><code class="language-yaml">type: dict
set_tag: &quot;type&quot;
schema:
  type: foo
  common: {type: dict}
  data_service:
    type: dict
    schema:
      renderers:
        type: list
        schema:
          type: dict
          when_tag_is:
            tag: type
            choices:
              foo: {&quot;type&quot;: dict, &quot;schema&quot;: {foo_specific: {type: string}}
              bar: {&quot;type&quot;: dict, &quot;schema&quot;: {bar_specific: {type: integer}}
</code></pre>
<h1><a class="header" href="#python-schema-syntax" id="python-schema-syntax">Python schema syntax</a></h1>
<p>If you want to construct a schema from Python code instead of storing it as
JSON or YAML, sureberus provides a more terse syntax for it.</p>
<p>Here's a standard dict-based schema, using an 80-character limit and strict
newline/indent-based line wrapping:</p>
<pre><code class="language-python">myschema = {
    'type': 'dict',
    'anyof': [
        {'schema': {'gradient': {'type': 'string'}}},
        {
            'schema': {
                'image': {'type': 'string'},
                'opacity': {'type': 'integer', 'default': 100},
            }
        },
    ],
}
</code></pre>
<p>And here is a <code>sureberus.schema</code>-based schema, using the same line-wrapping
rules:</p>
<pre><code class="language-python">from sureberus.schema import Dict, SubSchema, String, Integer
myschema = Dict(
    anyof=[
        SubSchema(gradient=String()),
        SubSchema(image=String(), opacity=Integer(default=100))
    ]
)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
